-- Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT = 'Покупатели';

INSERT INTO users (name, birthday_at,created_at,updated_at) VALUES
  ('Геннадий', '1990-10-05','1990-10-05','1990-10-05'),
  ('Наталья', '1984-11-12','1990-10-05','1990-10-05'),
  ('Александр', '1985-05-20','1990-10-05','1990-10-05'),
('Кристина', '2021-03-03', NULL, NULL ),
('Катя', '2021-03-03', NULL, '20.10.17'),
('Катя', '2021-03-03','20.10.17', NULL);
 select * from users;

UPDATE users set  
created_at = ( if (created_at is NULL,NOw(), created_at)),
updated_at= ( if (updated_at is NULL, NOw(), updated_at));


-- Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10. Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at varchar(255) ,
  updated_at varchar(255)
) COMMENT = 'Покупатели';

INSERT INTO users (name, birthday_at,created_at,updated_at) VALUES
  ('Геннадий', '1990-10-05',' 20.10.2017 8:10 ', '20.10.2017 8:10'),
  ('Наталья', '1984-11-12',' 20.10.2017 8:22 ', '20.10.2017 8:22'),
  ('Александр', '1985-05-20',' 20.11.2017 8:10 ', '20.11.2017 8:10'),
  ('Сергей', '1988-02-14',' 20.10.2017 8:10 ', '20.10.2017 8:10'),
  ('Иван', '1998-01-12',' 20.10.2020 8:10 ',null),
  ('Мария', '1992-08-29',null,null);


SELECT * from users u;

update
	users
set
	created_at = STR_TO_DATE (created_at,
	'%d.%m.%Y %H:%i'),
	updated_at = STR_TO_DATE (updated_at,
	'%d.%m.%Y %H:%i');
ALTER table users MODIFY COLUMN created_at DATETIME,
MODIFY COLUMN updated_at DATETIME;
desc users;

SELECT * from users u;


-- В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, если товар 
-- закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать  записи таким образом, чтобы они 
-- выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, после всех записей.
   SELECT * from storehouses_products sp ;
   INSERT into storehouses (name)
   values ('qwe'), ('ddfg'),('ddfgh');
  INSERT into storehouses_products (storehouse_id, product_id, value) values 
  (1, 5, 3), (1,2,4), (5,1,0);
 

SELECT value
FROM storehouses_products
ORDER BY IF( value= 0, 1, 0 ) , value;

-- Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.

SELECT * FROM catalogs WHERE id IN (5, 1, 2) ORDER BY FIELD(id, 5, 1, 2);


-- Подсчитайте средний возраст пользователей в таблице users.

SELECT
	FLOOR( AVG(age)) as avr_age
from (select (floor((TO_DAYS(now())-TO_DAYS(birthday_at))/365.25)) as age from users) as age;


-- Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. Следует учесть, что необходимы дни недели 
-- текущего года, а не года рождения.

SELECT
    DAYNAME (date) as day_of_week,
	count(1) as birthday_count
from
	(
	SELECT
		( CONCAT(year (curdate()),DATE_FORMAT( birthday_at,(".%m.%d"))))as date
	from
		users) date
	group by day_of_week
	order  by birthday_count DESC ;

